{
    "name": "Inbound Connections in Cluster",
    "description": "Use with the Node Graph visualization. This query outputs inbound connections to your cluster (connections made from external IPs).",
    "script": "# Copyright 2018- The Pixie Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# SPDX-License-Identifier: Apache-2.0\n\n'''\nThis query outputs a graph of the network connections to, from and within your cluster.\nUse this query with Grafana's Node Graph panel.\n\nThis query is for use with Grafana's Pixie Datasource Plugin only,\nas it uses Grafana macros for adding Grafana dashboard context.\nThis query is a modification of the px/inbound_conns script:\nhttps://github.com/pixie-io/pixie/tree/main/src/pxl_scripts/px/inbound_conns\n'''\n\n# $pixieCluster - work around to update the panel if this dashboard variable is present\n\n# Import Pixie's module for querying data.\nimport px\n\n\ndef inbound_conns():\n    df = px.DataFrame(table='conn_stats', start_time=__time_from)\n\n    df.namespace = df.ctx['namespace']\n    df.service = df.ctx['service']\n    df.node = df.ctx['node']\n    df.pod = df.ctx['pod']\n\n    # # Add optional filters:\n    # Filter IP address of sender.\n    # df = df[df.remote_addr == '10.38.0.15']\n    # # Filter namespace, service, node or pod name of receiving pod.\n    # # Pixie formats service and pod names in the <namespace>/<pod,service> format.\n    # df = df[df.service == 'px-sock-shop/front-end']\n    # df = df[df.pod == '']\n    # df = df[df.node == '']\n    # df = df[df.namespace == '']\n\n    # Trace-role of 2 means server-side tracing.\n    df = df[df.trace_role == 2]\n\n    # Filter out any connections from known pods.\n    df.remote_pod_id = px.ip_to_pod_id(df.remote_addr)\n    df.remote_service_id = px.ip_to_service_id(df.remote_addr)\n    df = df[df.remote_pod_id == '' and df.remote_service_id == '']\n\n    # Filter out connections from localhost.\n    df = df[not df.remote_addr == '127.0.0.1']\n\n    # Calculate connection stats for each process for each unique pod / remote_addr pair.\n    df = df.groupby(['pod', 'upid', 'remote_addr']).agg(\n        # The fields below are counters per UPID, so we take\n        # the min (starting value) and the max (ending value) to subtract them.\n        conn_open_min=('conn_open', px.min),\n        conn_open_max=('conn_open', px.max),\n        bytes_sent_min=('bytes_sent', px.min),\n        bytes_sent_max=('bytes_sent', px.max),\n        bytes_recv_min=('bytes_recv', px.min),\n        bytes_recv_max=('bytes_recv', px.max),\n    )\n\n    # Calculate connection stats over the time window.\n    df.conn_open = df.conn_open_max - df.conn_open_min\n    df.bytes_sent = df.bytes_sent_max - df.bytes_sent_min\n    df.bytes_recv = df.bytes_recv_max - df.bytes_recv_min\n\n    # Calculate connection stats for each unique pod / remote_addr pair. Since there\n    # may be multiple processes per pod we perform an additional aggregation to\n    # consolidate those into one entry.\n    df = df.groupby(['pod', 'remote_addr']).agg(\n        connections_open=('conn_open', px.sum),\n        bytes_sent=('bytes_sent', px.sum),\n        bytes_recv=('bytes_recv', px.sum),\n    )\n\n    # Convert to kilobytes.\n    df.kbytes_sent = df.bytes_sent / 1000\n    df.kbytes_recv = df.bytes_recv / 1000\n    df.kbytes_total = df.kbytes_sent + df.kbytes_recv\n\n    # Resolve remote addresses to public domain\n    df.domain = px.nslookup(df.remote_addr)\n    df.domain = px.select(df.domain == df.remote_addr, '', df.domain)\n\n    return df[['pod', 'remote_addr', 'domain', 'connections_open', 'kbytes_sent',\n               'kbytes_recv', 'kbytes_total']]\n\n\n# Construct the nodes table for the Node Graph panel.\n# https://grafana.com/docs/grafana/next/visualizations/node-graph/#node-parameters\ndef nodes():\n    df1 = inbound_conns()\n    df1.id = df1.pod\n    df1.title = df1.pod\n    df1 = df1.groupby(['id', 'title']).agg()\n    df2 = inbound_conns()\n    df2.id = df2.remote_addr\n    df2.title = df2.remote_addr\n    df2 = df2.groupby(['id', 'title']).agg()\n    return df1.append(df2)\n\n\n# Construct the edges table for the Node Graph panel.\n# https://grafana.com/docs/grafana/next/visualizations/node-graph/#edge-parameters\ndef edges():\n    df = inbound_conns()\n    df.source = df.remote_addr\n    df.target = df.pod\n    df.id = df.source + '-' + df.target\n    df.mainStat = df.kbytes_sent\n    df.secondaryStat = df.kbytes_recv\n    return df[['id', 'source', 'target', 'mainStat', 'secondaryStat']]\n\n\n# Display the tables.\nnodes = nodes()\npx.display(nodes, \"nodes\")\n\nedges = edges()\npx.display(edges, \"edges\")"
}
